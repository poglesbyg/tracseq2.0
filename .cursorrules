# TracSeq 2.0 Laboratory Management System - Cursor Rules

## ðŸ”„ Development Cycle (CRITICAL - Always Follow)

**Before writing any code:**
1. Come up with an extremely good plan
2. Review the plan thoroughly 
3. Ask user for permission to execute the plan

**After implementing changes:**
1. Run: `pnpm typecheck` - Type checking across all TypeScript projects
2. Run: `pnpm lint` - Linting across all projects
3. If linting errors exist: `pnpm fix` - Auto-fix where possible
4. Run tests: `pnpm test --filter @app/<web/api/db>` - Targeted testing
5. **NEVER** try to start dev servers or curl local endpoints

## ðŸ—ï¸ Technology Stack & Guidelines

### Package Management
- **Primary**: pnpm (v10.12.2+) for all Node.js/TypeScript projects
- **Workspace**: Monorepo structure with pnpm workspaces
- **Commands**: Use `pnpm` prefix for all package operations

### Frontend (React/TypeScript)
- **Framework**: React 18.3+ with TypeScript 5.8+
- **Build Tool**: Vite 6.3+ for fast development and building
- **Styling**: Tailwind CSS 3.4+ with Headless UI components
- **State Management**: TanStack Query for server state, React hooks for local state
- **Testing**: Jest 29+ with Testing Library for component testing

### Backend Services (Rust)
- **Framework**: tokio-based async services with axum/warp
- **Database**: PostgreSQL with SQLx for type-safe queries
- **Validation**: Custom domain validation with serde
- **Error Handling**: Comprehensive error types with proper HTTP responses
- **Testing**: Unit tests with `cargo test`, integration tests for APIs

### Python Services (AI/RAG)
- **AI Framework**: Custom RAG implementation with vector databases
- **Web Framework**: FastAPI for API services
- **Database**: PostgreSQL with SQLAlchemy/Alembic migrations
- **Testing**: pytest with comprehensive coverage
- **Dependencies**: Use requirements.txt with pinned versions

## ðŸ§¬ Laboratory Domain Logic

### Sample Lifecycle States
```
Pending â†’ Validated â†’ InStorage â†’ InSequencing â†’ Completed
```
- **State Transitions**: Must be validated with domain rules
- **Barcode Generation**: Follow laboratory naming conventions
- **Chain of Custody**: Blockchain-based tracking required
- **Temperature Zones**: -80Â°C, -20Â°C, 4Â°C, RT, 37Â°C with IoT monitoring

### Critical Business Rules
1. **Sample Integrity**: Every state change must be audited
2. **Storage Compliance**: Temperature violations trigger immediate alerts  
3. **AI Processing**: RAG confidence scores must exceed 0.85 for auto-processing
4. **Workflow Orchestration**: Use Saga pattern for distributed transactions

## ðŸ¤– AI/LLM Integration Guidelines

### RAG Document Processing
- **File Location**: `lab_submission_rag/rag_orchestrator.py`
- **Confidence Scoring**: Implement threshold-based processing (>0.85 auto, <0.85 manual review)
- **Extraction Categories**: Administrative data, sample specs, sequencing requirements, storage conditions
- **Error Handling**: Graceful degradation for LLM failures

### Document Types Supported
- Laboratory submission forms (PDF, Word, plain text)
- Sample metadata spreadsheets
- Equipment calibration reports
- Quality control documentation

## ðŸ›ï¸ Microservices Architecture

### Service Communication
- **Pattern**: Event-driven architecture with 10+ microservices
- **Messaging**: Use event_service for inter-service communication
- **Transactions**: Saga pattern in transaction_service for distributed operations
- **Discovery**: Service mesh configuration in service-mesh/

### Key Services & Responsibilities
1. **sample_service** (Rust) - Sample lifecycle management
2. **enhanced_storage_service** (Rust) - Storage/IoT/blockchain tracking  
3. **lab_submission_rag** (Python) - AI document processing
4. **transaction_service** (Rust) - Workflow orchestration
5. **auth_service** (Rust) - Authentication/authorization
6. **api_gateway** (Python) - Request routing and rate limiting

## ðŸ“‹ Development Standards

### Code Quality
- **No Placeholders**: Never use `# ... rest of processing ...` - always complete code
- **Type Safety**: Strict TypeScript, Rust ownership rules, Python type hints
- **Error Handling**: Comprehensive error types, proper HTTP status codes
- **Documentation**: Inline docs for complex business logic

### Problem-Solving Approach
1. **OBSERVE**: Analyze logs, error messages, and system state
2. **REASON**: Identify root cause with evidence-based analysis  
3. **PLAN**: Break complex problems into smaller, manageable steps
4. **IMPLEMENT**: Make targeted changes to relevant code only
5. **VERIFY**: Test changes thoroughly before completion

### Git Workflow
- **Branches**: Feature branches from `dev`, PRs to `dev`
- **Commits**: Conventional commits with clear, descriptive messages
- **Testing**: All PRs must pass CI/CD pipeline checks

## ðŸ§ª Testing Strategy

### Frontend Testing
```bash
pnpm test --filter @app/web           # React component tests
pnpm test:coverage --filter @app/web  # Coverage reports
```

### Backend Testing  
```bash
cargo test                            # Rust unit/integration tests
pytest                               # Python service tests
```

### Integration Testing
- **Laboratory Workflows**: End-to-end sample processing scenarios
- **AI Pipeline**: RAG document processing with known test documents
- **Storage Events**: IoT sensor simulation and blockchain verification

## ðŸ³ Deployment & DevOps

### Docker Strategy
- **Development**: `docker-compose.yml` for local development
- **Production**: `deploy/production/docker-compose.production.yml`
- **Monitoring**: Prometheus/Grafana stack in `monitoring/`

### Environment Management
- **Config**: Service-specific config in each service directory
- **Secrets**: Use environment variables, never hardcode credentials
- **Databases**: Migration scripts in `migrations/` directories

## ðŸš¨ Debugging & Troubleshooting

### Common Issues
1. **Type Errors**: Run `pnpm typecheck` to identify TypeScript issues
2. **Linting**: Use `pnpm fix` for auto-fixable ESLint issues  
3. **Dependencies**: Check pnpm-lock.yaml for version conflicts
4. **Services**: Use `validate_deployment.py` for service health checks

### Laboratory-Specific Debugging
- **Sample State Issues**: Check state transition logs in database
- **Temperature Alerts**: Verify IoT sensor data in enhanced_storage_service
- **RAG Processing**: Check confidence scores in lab_submission_rag logs
- **Workflow Failures**: Examine saga state in transaction_service

## ðŸ“ Key File Locations

### Configuration
- `pnpm-workspace.yaml` - Workspace configuration
- `deploy/tracseq.env` - Environment variables
- `Cargo.toml` - Rust workspace configuration

### Critical Business Logic
- `sample_service/src/models.rs` - Sample domain models
- `enhanced_storage_service/src/handlers/storage.rs` - Storage management
- `lab_submission_rag/rag_orchestrator.py` - AI document processing
- `transaction_service/src/workflows/laboratory/mod.rs` - Workflow orchestration

### Frontend
- `lab_manager/frontend/src/` - React application
- `lab_manager/frontend/package.json` - Frontend dependencies and scripts

## ðŸŽ¯ Performance & Optimization

### Backend Performance
- **Database**: Use connection pooling, prepared statements
- **Caching**: Implement Redis for frequently accessed data
- **Monitoring**: Track metrics with Prometheus

### Frontend Performance  
- **Bundle Size**: Use Vite code splitting and tree shaking
- **API Calls**: Implement TanStack Query for caching and deduplication
- **UI Performance**: Use React.memo for expensive components

## ðŸ”’ Security Considerations

### Authentication
- **JWT Tokens**: Implemented in auth_service
- **Role-Based Access**: Laboratory hierarchy alignment
- **API Security**: Rate limiting in api_gateway

### Data Protection
- **Sample Data**: PHI/PII protection required
- **Chain of Custody**: Immutable blockchain tracking
- **Audit Logs**: All critical operations must be logged

---

**Domain Context**: This is a sophisticated laboratory management system with AI-powered document processing, IoT integration, and blockchain-based sample tracking. The system emphasizes compliance, sample integrity, and workflow automation across 10+ microservices.

**Architecture**: Event-driven microservices with Rust backends, Python AI services, React frontend, and comprehensive monitoring/observability.

*Context improved by Giga AI*
